/*
 * Copyright 2022 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

import { getMultiTypeFromValue, MultiTypeInputType } from '@harness/uicore'
import { intersection, isEmpty } from 'lodash-es'
import { getScopeFromValue } from '@common/components/EntityReference/EntityReference'
import { Scope } from '@common/interfaces/SecretsInterface'
import type { ManifestConfig, ManifestConfigWrapper } from 'services/cd-ng'
import { GitRepoName, ManifestStoreMap } from '../Manifesthelper'
import type {
  CommandFlags,
  CustomManifestManifestDataType,
  HelmHarnessFileStoreFormData,
  HelmWithGcsDataType,
  HelmWithGITDataType,
  HelmWithHTTPDataType,
  HelmWithOCIDataType,
  ManifestTypes
} from '../ManifestInterface'
import { allowedManifestForSingleAddition } from './CommonManifestDetails/utils'

type formDataType =
  | HelmWithGcsDataType
  | HelmWithGITDataType
  | HelmWithHTTPDataType
  | HelmWithOCIDataType
  | HelmHarnessFileStoreFormData
  | CustomManifestManifestDataType

const getRepoNameBasedonScope = (initialValues: ManifestConfig, prevStepData: any): string => {
  const connectorScope = getScopeFromValue(initialValues?.spec.store?.spec.connectorRef)
  switch (connectorScope) {
    case Scope.ACCOUNT:
      return initialValues?.spec.store?.spec.connectorRef ===
        `account.${prevStepData?.connectorRef?.connector?.identifier}`
        ? initialValues?.spec.store?.spec.repoName
        : ''

    case Scope.PROJECT:
      return prevStepData?.connectorRef?.connector?.identifier === initialValues?.spec.store?.spec.connectorRef
        ? initialValues?.spec.store?.spec.repoName
        : ''

    case Scope.ORG:
      return `${prevStepData?.connectorRef?.scope}.${prevStepData?.connectorRef?.connector?.identifier}` ===
        initialValues?.spec.store?.spec.connectorRef
        ? initialValues?.spec.store?.spec.repoName
        : ''

    default:
      return ''
  }
}

export const getRepositoryName = (prevStepData: any, initialValues: ManifestConfig): string => {
  const gitConnectionType: string = prevStepData?.store === ManifestStoreMap.Git ? 'connectionType' : 'type'
  const connectionType =
    prevStepData?.connectorRef?.connector?.spec?.[gitConnectionType] === GitRepoName.Repo ||
    prevStepData?.urlType === GitRepoName.Repo
      ? GitRepoName.Repo
      : GitRepoName.Account

  if (getMultiTypeFromValue(prevStepData?.connectorRef) !== MultiTypeInputType.FIXED) {
    return prevStepData.repoName
  } else {
    if (connectionType === GitRepoName.Repo) {
      return prevStepData.connectorRef?.connector?.spec.url
    }
    return getRepoNameBasedonScope(initialValues, prevStepData)
  }
}

export const handleCommandFlagsSubmitData = (
  manifestObj: ManifestConfigWrapper,
  formData: formDataType & {
    store?: string
    connectorRef?: string
  }
): void => {
  if (formData?.commandFlags.length && formData?.commandFlags[0].commandType) {
    ;(manifestObj.manifest as ManifestConfig).spec.commandFlags = formData?.commandFlags.map(
      (commandFlag: CommandFlags) =>
        commandFlag.commandType && commandFlag.flag
          ? {
              commandType: commandFlag.commandType,
              flag: commandFlag.flag
            }
          : {}
    )
    const filteredCommandFlags = manifestObj?.manifest?.spec?.commandFlags.filter(
      (currFlag: CommandFlags) => !isEmpty(currFlag)
    )
    if (filteredCommandFlags.length === 0 && manifestObj?.manifest?.spec) {
      delete manifestObj.manifest.spec.commandFlags
    }
  }
}

export const removeEmptyFieldsFromStringArray = (inputArray: string[] | undefined): string[] | undefined => {
  return inputArray?.filter((path: string) => !!path)
}

export const getConnectorPath = (type: string, data: any): string => {
  switch (type) {
    case ManifestStoreMap.OciHelmChart:
      return data?.spec?.store?.spec?.config?.spec?.connectorRef
    default:
      return data?.spec?.store?.spec?.connectorRef
  }
}
export const filePathWidth = 600

/**
 *
 * @param listOfManifests - selected manifests
 * @returns list of manifest types to be disabled after single addition
 */
export const getListOfDisabledManifestTypes = (listOfManifests: ManifestConfigWrapper[]): ManifestTypes[] => {
  const selectedManifestTypes = listOfManifests.map(
    (item: ManifestConfigWrapper) => item.manifest?.type as ManifestTypes
  )
  return intersection(selectedManifestTypes, allowedManifestForSingleAddition)
}
