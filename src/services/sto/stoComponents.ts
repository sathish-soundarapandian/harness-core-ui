/**
 * Generated by @openapi-codegen
 *
 * @version 0.1.0-beta
 */
import * as reactQuery from '@tanstack/react-query'
import type { ErrorWrapper } from './fetcher'
import { StoContext, useStoContext } from './stoContext'
import { stoFetch } from './stoFetcher'
import type * as Schemas from './stoSchemas'

export type UsageReportUsageQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Timestamp
   *
   * @example 1670427991307
   * @format int64
   */
  timestamp: number
}

export type UsageReportUsageError = ErrorWrapper<{
  status: 500
  payload: Schemas.NotFound
}>

export type UsageReportUsageVariables = {
  queryParams: UsageReportUsageQueryParams
} & StoContext['fetcherOptions']

/**
 * Report usage
 */
export const fetchUsageReportUsage = (variables: UsageReportUsageVariables) =>
  stoFetch<Schemas.UsageReportUsageResponseBody, UsageReportUsageError, undefined, {}, UsageReportUsageQueryParams, {}>(
    { url: '/api/usage', method: 'get', ...variables }
  )

/**
 * Report usage
 */
export const useUsageReportUsage = <TData>(
  variables: UsageReportUsageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UsageReportUsageResponseBody, UsageReportUsageError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.UsageReportUsageResponseBody, UsageReportUsageError, TData>(
    queryKeyFn({ path: '/api/usage', operationId: 'usageReportUsage', variables }),
    () => fetchUsageReportUsage({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type TokenV1IssueTokenV1QueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TokenV1IssueTokenV1Headers = {
  /*
   * Harness internal shared secret
   *
   * @example 3q7uiERGH78heq3weg
   */
  ['X-Harness-Token']: string
}

export type TokenV1IssueTokenV1Error = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TokenV1IssueTokenV1Variables = {
  headers: TokenV1IssueTokenV1Headers
  queryParams: TokenV1IssueTokenV1QueryParams
} & StoContext['fetcherOptions']

/**
 * Issue a cross-service token
 */
export const fetchTokenV1IssueTokenV1 = (variables: TokenV1IssueTokenV1Variables) =>
  stoFetch<
    undefined,
    TokenV1IssueTokenV1Error,
    undefined,
    TokenV1IssueTokenV1Headers,
    TokenV1IssueTokenV1QueryParams,
    {}
  >({ url: '/api/v1/token', method: 'get', ...variables })

/**
 * Issue a cross-service token
 */
export const useTokenV1IssueTokenV1 = <TData>(
  variables: TokenV1IssueTokenV1Variables,
  options?: Omit<reactQuery.UseQueryOptions<undefined, TokenV1IssueTokenV1Error, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<undefined, TokenV1IssueTokenV1Error, TData>(
    queryKeyFn({ path: '/api/v1/token', operationId: 'tokenV1IssueTokenV1', variables }),
    () => fetchTokenV1IssueTokenV1({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type ExemptionsListExemptionsQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @minimum 0
   */
  page?: number
  /*
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
}

export type ExemptionsListExemptionsError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsListExemptionsVariables = {
  queryParams: ExemptionsListExemptionsQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Exemptions
 */
export const fetchExemptionsListExemptions = (variables: ExemptionsListExemptionsVariables) =>
  stoFetch<
    Schemas.ExemptionsListExemptionsResponseBody,
    ExemptionsListExemptionsError,
    undefined,
    {},
    ExemptionsListExemptionsQueryParams,
    {}
  >({ url: '/api/v2/exemptions', method: 'get', ...variables })

/**
 * List a collection of Exemptions
 */
export const useExemptionsListExemptions = <TData>(
  variables: ExemptionsListExemptionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ExemptionsListExemptionsResponseBody, ExemptionsListExemptionsError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ExemptionsListExemptionsResponseBody, ExemptionsListExemptionsError, TData>(
    queryKeyFn({ path: '/api/v2/exemptions', operationId: 'exemptionsListExemptions', variables }),
    () => fetchExemptionsListExemptions({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type ExemptionsCreateExemptionQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * ID of the Harness Organization to which the exemption applies. Cannot be specified alongside "targetId".
   *
   * @example your_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /*
   * ID of the Harness Project to which the exemption applies. You must also specify "orgId". Cannot be specified alongside "targetId".
   *
   * @example your_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
}

export type ExemptionsCreateExemptionError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsCreateExemptionVariables = {
  body: Schemas.CreateExemptionRequestBody
  queryParams: ExemptionsCreateExemptionQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Exemption
 */
export const fetchExemptionsCreateExemption = (variables: ExemptionsCreateExemptionVariables) =>
  stoFetch<
    Schemas.ExemptionsCreateExemptionResponseBody,
    ExemptionsCreateExemptionError,
    Schemas.CreateExemptionRequestBody,
    {},
    ExemptionsCreateExemptionQueryParams,
    {}
  >({ url: '/api/v2/exemptions', method: 'post', ...variables })

/**
 * Create a new Exemption
 */
export const useExemptionsCreateExemption = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ExemptionsCreateExemptionResponseBody,
      ExemptionsCreateExemptionError,
      ExemptionsCreateExemptionVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.ExemptionsCreateExemptionResponseBody,
    ExemptionsCreateExemptionError,
    ExemptionsCreateExemptionVariables
  >(
    (variables: ExemptionsCreateExemptionVariables) =>
      fetchExemptionsCreateExemption({ ...fetcherOptions, ...variables }),
    options
  )
}

export type ExemptionsDeleteExemptionPathParams = {
  /*
   * The ID of the Exemption to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ExemptionsDeleteExemptionQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
}

export type ExemptionsDeleteExemptionError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsDeleteExemptionVariables = {
  pathParams: ExemptionsDeleteExemptionPathParams
  queryParams: ExemptionsDeleteExemptionQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Exemption
 */
export const fetchExemptionsDeleteExemption = (variables: ExemptionsDeleteExemptionVariables) =>
  stoFetch<
    undefined,
    ExemptionsDeleteExemptionError,
    undefined,
    {},
    ExemptionsDeleteExemptionQueryParams,
    ExemptionsDeleteExemptionPathParams
  >({ url: '/api/v2/exemptions/{id}', method: 'delete', ...variables })

/**
 * Delete an existing Exemption
 */
export const useExemptionsDeleteExemption = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, ExemptionsDeleteExemptionError, ExemptionsDeleteExemptionVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<undefined, ExemptionsDeleteExemptionError, ExemptionsDeleteExemptionVariables>(
    (variables: ExemptionsDeleteExemptionVariables) =>
      fetchExemptionsDeleteExemption({ ...fetcherOptions, ...variables }),
    options
  )
}

export type ExemptionsFindExemptionByIdPathParams = {
  /*
   * The ID of the Exemption to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ExemptionsFindExemptionByIdQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ExemptionsFindExemptionByIdError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsFindExemptionByIdVariables = {
  pathParams: ExemptionsFindExemptionByIdPathParams
  queryParams: ExemptionsFindExemptionByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Exemption by ID
 */
export const fetchExemptionsFindExemptionById = (variables: ExemptionsFindExemptionByIdVariables) =>
  stoFetch<
    Schemas.Exemption,
    ExemptionsFindExemptionByIdError,
    undefined,
    {},
    ExemptionsFindExemptionByIdQueryParams,
    ExemptionsFindExemptionByIdPathParams
  >({ url: '/api/v2/exemptions/{id}', method: 'get', ...variables })

/**
 * Find Exemption by ID
 */
export const useExemptionsFindExemptionById = <TData>(
  variables: ExemptionsFindExemptionByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Exemption, ExemptionsFindExemptionByIdError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Exemption, ExemptionsFindExemptionByIdError, TData>(
    queryKeyFn({ path: '/api/v2/exemptions/{id}', operationId: 'exemptionsFindExemptionById', variables }),
    () => fetchExemptionsFindExemptionById({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type ExemptionsUpdateExemptionPathParams = {
  /*
   * The ID of the Exemption to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ExemptionsUpdateExemptionQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * ID of the Harness Organization to which the exemption applies. Cannot be specified alongside "targetId".
   *
   * @example your_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /*
   * ID of the Harness Project to which the exemption applies. You must also specify "orgId". Cannot be specified alongside "targetId".
   *
   * @example your_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
}

export type ExemptionsUpdateExemptionError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsUpdateExemptionVariables = {
  body: Schemas.UpdateExemptionRequestBody
  pathParams: ExemptionsUpdateExemptionPathParams
  queryParams: ExemptionsUpdateExemptionQueryParams
} & StoContext['fetcherOptions']

/**
 * Update an existing Exemption
 */
export const fetchExemptionsUpdateExemption = (variables: ExemptionsUpdateExemptionVariables) =>
  stoFetch<
    Schemas.Exemption,
    ExemptionsUpdateExemptionError,
    Schemas.UpdateExemptionRequestBody,
    {},
    ExemptionsUpdateExemptionQueryParams,
    ExemptionsUpdateExemptionPathParams
  >({ url: '/api/v2/exemptions/{id}', method: 'put', ...variables })

/**
 * Update an existing Exemption
 */
export const useExemptionsUpdateExemption = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Exemption,
      ExemptionsUpdateExemptionError,
      ExemptionsUpdateExemptionVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.Exemption, ExemptionsUpdateExemptionError, ExemptionsUpdateExemptionVariables>(
    (variables: ExemptionsUpdateExemptionVariables) =>
      fetchExemptionsUpdateExemption({ ...fetcherOptions, ...variables }),
    options
  )
}

export type ExemptionsApproveExemptionPathParams = {
  /*
   * The ID of the Exemption to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
  /*
   * The approval action to take on the Exemption
   *
   * @example approve
   */
  action: 'approve' | 'reject'
}

export type ExemptionsApproveExemptionQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
}

export type ExemptionsApproveExemptionError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ExemptionsApproveExemptionVariables = {
  body: Schemas.ApproveExemptionRequestBody
  pathParams: ExemptionsApproveExemptionPathParams
  queryParams: ExemptionsApproveExemptionQueryParams
} & StoContext['fetcherOptions']

/**
 * Approve/reject an existing Exemption
 */
export const fetchExemptionsApproveExemption = (variables: ExemptionsApproveExemptionVariables) =>
  stoFetch<
    Schemas.Exemption,
    ExemptionsApproveExemptionError,
    Schemas.ApproveExemptionRequestBody,
    {},
    ExemptionsApproveExemptionQueryParams,
    ExemptionsApproveExemptionPathParams
  >({ url: '/api/v2/exemptions/{id}/{action}', method: 'put', ...variables })

/**
 * Approve/reject an existing Exemption
 */
export const useExemptionsApproveExemption = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Exemption,
      ExemptionsApproveExemptionError,
      ExemptionsApproveExemptionVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.Exemption,
    ExemptionsApproveExemptionError,
    ExemptionsApproveExemptionVariables
  >(
    (variables: ExemptionsApproveExemptionVariables) =>
      fetchExemptionsApproveExemption({ ...fetcherOptions, ...variables }),
    options
  )
}

export type FrontendExecutionIssueCountsQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
  /*
   * Comma-separated list of Harness Execution IDs for which to count Security Issues
   *
   * @example abcdef1234567890ghijkl,mnopqr0987654321stuvwx
   * @pattern [\dA-Za-z_-]{22}(,[\dA-Za-z_-]{22})*
   */
  executionIds: string
}

export type FrontendExecutionIssueCountsError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendExecutionIssueCountsResponse = {
  [key: string]: Schemas.IssueCounts
}

export type FrontendExecutionIssueCountsVariables = {
  queryParams: FrontendExecutionIssueCountsQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns counts of active Security Issues for one or more Pipeline Executions
 */
export const fetchFrontendExecutionIssueCounts = (variables: FrontendExecutionIssueCountsVariables) =>
  stoFetch<
    FrontendExecutionIssueCountsResponse,
    FrontendExecutionIssueCountsError,
    undefined,
    {},
    FrontendExecutionIssueCountsQueryParams,
    {}
  >({ url: '/api/v2/frontend/issue-counts', method: 'get', ...variables })

/**
 * Returns counts of active Security Issues for one or more Pipeline Executions
 */
export const useFrontendExecutionIssueCounts = <TData>(
  variables: FrontendExecutionIssueCountsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<FrontendExecutionIssueCountsResponse, FrontendExecutionIssueCountsError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<FrontendExecutionIssueCountsResponse, FrontendExecutionIssueCountsError, TData>(
    queryKeyFn({ path: '/api/v2/frontend/issue-counts', operationId: 'frontendExecutionIssueCounts', variables }),
    () => fetchFrontendExecutionIssueCounts({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type FrontendOverviewQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
  /*
   * Number of days of Baseline Issue counts to return
   *
   * @default 30
   * @example 56
   * @minimum 1
   * @maximum 90
   */
  days?: number
}

export type FrontendOverviewError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendOverviewVariables = {
  queryParams: FrontendOverviewQueryParams
} & StoContext['fetcherOptions']

/**
 * Provides data needed by the Overview page
 */
export const fetchFrontendOverview = (variables: FrontendOverviewVariables) =>
  stoFetch<Schemas.FrontendOverviewResponseBody, FrontendOverviewError, undefined, {}, FrontendOverviewQueryParams, {}>(
    { url: '/api/v2/frontend/overview', method: 'get', ...variables }
  )

/**
 * Provides data needed by the Overview page
 */
export const useFrontendOverview = <TData>(
  variables: FrontendOverviewVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendOverviewResponseBody, FrontendOverviewError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendOverviewResponseBody, FrontendOverviewError, TData>(
    queryKeyFn({ path: '/api/v2/frontend/overview', operationId: 'frontendOverview', variables }),
    () => fetchFrontendOverview({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type FrontendPipelineSecurityQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId?: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId?: string
  /*
   * Harness Execution ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  executionId: string
}

export type FrontendPipelineSecurityError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendPipelineSecurityVariables = {
  queryParams: FrontendPipelineSecurityQueryParams
} & StoContext['fetcherOptions']

/**
 * Provide data needed by the PipelineSecurityView
 */
export const fetchFrontendPipelineSecurity = (variables: FrontendPipelineSecurityVariables) =>
  stoFetch<
    Schemas.FrontendPipelineSecurityResponseBody,
    FrontendPipelineSecurityError,
    undefined,
    {},
    FrontendPipelineSecurityQueryParams,
    {}
  >({ url: '/api/v2/frontend/pipeline-security', method: 'get', ...variables })

/**
 * Provide data needed by the PipelineSecurityView
 */
export const useFrontendPipelineSecurity = <TData>(
  variables: FrontendPipelineSecurityVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendPipelineSecurityResponseBody, FrontendPipelineSecurityError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendPipelineSecurityResponseBody, FrontendPipelineSecurityError, TData>(
    queryKeyFn({ path: '/api/v2/frontend/pipeline-security', operationId: 'frontendPipelineSecurity', variables }),
    () => fetchFrontendPipelineSecurity({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type FrontendSecurityReviewQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type FrontendSecurityReviewError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendSecurityReviewVariables = {
  queryParams: FrontendSecurityReviewQueryParams
} & StoContext['fetcherOptions']

/**
 * Provides data needed by the Security Review page
 */
export const fetchFrontendSecurityReview = (variables: FrontendSecurityReviewVariables) =>
  stoFetch<
    Schemas.FrontendSecurityReviewResponseBody,
    FrontendSecurityReviewError,
    undefined,
    {},
    FrontendSecurityReviewQueryParams,
    {}
  >({ url: '/api/v2/frontend/security-review', method: 'get', ...variables })

/**
 * Provides data needed by the Security Review page
 */
export const useFrontendSecurityReview = <TData>(
  variables: FrontendSecurityReviewVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendSecurityReviewResponseBody, FrontendSecurityReviewError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendSecurityReviewResponseBody, FrontendSecurityReviewError, TData>(
    queryKeyFn({ path: '/api/v2/frontend/security-review', operationId: 'frontendSecurityReview', variables }),
    () => fetchFrontendSecurityReview({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type FrontendTestTargetsQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type FrontendTestTargetsError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type FrontendTestTargetsVariables = {
  queryParams: FrontendTestTargetsQueryParams
} & StoContext['fetcherOptions']

/**
 * Provides data needed by the Test Targets page
 */
export const fetchFrontendTestTargets = (variables: FrontendTestTargetsVariables) =>
  stoFetch<
    Schemas.FrontendTestTargetsResponseBody,
    FrontendTestTargetsError,
    undefined,
    {},
    FrontendTestTargetsQueryParams,
    {}
  >({ url: '/api/v2/frontend/test-targets', method: 'get', ...variables })

/**
 * Provides data needed by the Test Targets page
 */
export const useFrontendTestTargets = <TData>(
  variables: FrontendTestTargetsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FrontendTestTargetsResponseBody, FrontendTestTargetsError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.FrontendTestTargetsResponseBody, FrontendTestTargetsError, TData>(
    queryKeyFn({ path: '/api/v2/frontend/test-targets', operationId: 'frontendTestTargets', variables }),
    () => fetchFrontendTestTargets({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type IssuesListIssuesQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @minimum 0
   */
  page?: number
  /*
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
}

export type IssuesListIssuesError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesListIssuesVariables = {
  queryParams: IssuesListIssuesQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Security Issues
 */
export const fetchIssuesListIssues = (variables: IssuesListIssuesVariables) =>
  stoFetch<Schemas.IssuesListIssuesResponseBody, IssuesListIssuesError, undefined, {}, IssuesListIssuesQueryParams, {}>(
    { url: '/api/v2/issues', method: 'get', ...variables }
  )

/**
 * List a collection of Security Issues
 */
export const useIssuesListIssues = <TData>(
  variables: IssuesListIssuesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.IssuesListIssuesResponseBody, IssuesListIssuesError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.IssuesListIssuesResponseBody, IssuesListIssuesError, TData>(
    queryKeyFn({ path: '/api/v2/issues', operationId: 'issuesListIssues', variables }),
    () => fetchIssuesListIssues({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type IssuesCreateIssueQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type IssuesCreateIssueError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesCreateIssueVariables = {
  body: Schemas.CreateIssueRequestBody
  queryParams: IssuesCreateIssueQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Security Issue
 */
export const fetchIssuesCreateIssue = (variables: IssuesCreateIssueVariables) =>
  stoFetch<
    Schemas.IDResult,
    IssuesCreateIssueError,
    Schemas.CreateIssueRequestBody,
    {},
    IssuesCreateIssueQueryParams,
    {}
  >({ url: '/api/v2/issues', method: 'post', ...variables })

/**
 * Create a new Security Issue
 */
export const useIssuesCreateIssue = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.IDResult, IssuesCreateIssueError, IssuesCreateIssueVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.IDResult, IssuesCreateIssueError, IssuesCreateIssueVariables>(
    (variables: IssuesCreateIssueVariables) => fetchIssuesCreateIssue({ ...fetcherOptions, ...variables }),
    options
  )
}

export type IssuesDeleteIssuePathParams = {
  /*
   * The ID of the Security Issue to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type IssuesDeleteIssueQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type IssuesDeleteIssueError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesDeleteIssueVariables = {
  pathParams: IssuesDeleteIssuePathParams
  queryParams: IssuesDeleteIssueQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Security Issue
 */
export const fetchIssuesDeleteIssue = (variables: IssuesDeleteIssueVariables) =>
  stoFetch<undefined, IssuesDeleteIssueError, undefined, {}, IssuesDeleteIssueQueryParams, IssuesDeleteIssuePathParams>(
    { url: '/api/v2/issues/{id}', method: 'delete', ...variables }
  )

/**
 * Delete an existing Security Issue
 */
export const useIssuesDeleteIssue = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, IssuesDeleteIssueError, IssuesDeleteIssueVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<undefined, IssuesDeleteIssueError, IssuesDeleteIssueVariables>(
    (variables: IssuesDeleteIssueVariables) => fetchIssuesDeleteIssue({ ...fetcherOptions, ...variables }),
    options
  )
}

export type IssuesFindIssueByIdPathParams = {
  /*
   * The ID of the Security Issue to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type IssuesFindIssueByIdQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
  /*
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId?: string
}

export type IssuesFindIssueByIdError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type IssuesFindIssueByIdVariables = {
  pathParams: IssuesFindIssueByIdPathParams
  queryParams: IssuesFindIssueByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Security Issue by ID
 */
export const fetchIssuesFindIssueById = (variables: IssuesFindIssueByIdVariables) =>
  stoFetch<
    Schemas.Issue,
    IssuesFindIssueByIdError,
    undefined,
    {},
    IssuesFindIssueByIdQueryParams,
    IssuesFindIssueByIdPathParams
  >({ url: '/api/v2/issues/{id}', method: 'get', ...variables })

/**
 * Find Security Issue by ID
 */
export const useIssuesFindIssueById = <TData>(
  variables: IssuesFindIssueByIdVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.Issue, IssuesFindIssueByIdError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Issue, IssuesFindIssueByIdError, TData>(
    queryKeyFn({ path: '/api/v2/issues/{id}', operationId: 'issuesFindIssueById', variables }),
    () => fetchIssuesFindIssueById({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type ProductsListProductsQueryParams = {
  /*
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @minimum 0
   */
  page?: number
  /*
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
  /*
   * Resource name
   *
   * @example NodeGoat
   */
  name?: string
}

export type ProductsListProductsError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ProductsListProductsVariables = {
  queryParams?: ProductsListProductsQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Scan Tools
 */
export const fetchProductsListProducts = (variables: ProductsListProductsVariables) =>
  stoFetch<
    Schemas.ProductsListProductsResponseBody,
    ProductsListProductsError,
    undefined,
    {},
    ProductsListProductsQueryParams,
    {}
  >({ url: '/api/v2/products', method: 'get', ...variables })

/**
 * List a collection of Scan Tools
 */
export const useProductsListProducts = <TData>(
  variables: ProductsListProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ProductsListProductsResponseBody, ProductsListProductsError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ProductsListProductsResponseBody, ProductsListProductsError, TData>(
    queryKeyFn({ path: '/api/v2/products', operationId: 'productsListProducts', variables }),
    () => fetchProductsListProducts({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type ProductsFindProductByIdPathParams = {
  /*
   * The ID of the Scan Tool to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ProductsFindProductByIdError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ProductsFindProductByIdVariables = {
  pathParams: ProductsFindProductByIdPathParams
} & StoContext['fetcherOptions']

/**
 * Find Scan Tool by ID
 */
export const fetchProductsFindProductById = (variables: ProductsFindProductByIdVariables) =>
  stoFetch<Schemas.Product, ProductsFindProductByIdError, undefined, {}, {}, ProductsFindProductByIdPathParams>({
    url: '/api/v2/products/{id}',
    method: 'get',
    ...variables
  })

/**
 * Find Scan Tool by ID
 */
export const useProductsFindProductById = <TData>(
  variables: ProductsFindProductByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Product, ProductsFindProductByIdError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Product, ProductsFindProductByIdError, TData>(
    queryKeyFn({ path: '/api/v2/products/{id}', operationId: 'productsFindProductById', variables }),
    () => fetchProductsFindProductById({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type ScansListScansQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @minimum 0
   */
  page?: number
  /*
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
  /*
   * Harness Execution ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  executionId?: string
}

export type ScansListScansError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansListScansVariables = {
  queryParams: ScansListScansQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Security Test Scans
 */
export const fetchScansListScans = (variables: ScansListScansVariables) =>
  stoFetch<Schemas.ScansListScansResponseBody, ScansListScansError, undefined, {}, ScansListScansQueryParams, {}>({
    url: '/api/v2/scans',
    method: 'get',
    ...variables
  })

/**
 * List a collection of Security Test Scans
 */
export const useScansListScans = <TData>(
  variables: ScansListScansVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ScansListScansResponseBody, ScansListScansError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ScansListScansResponseBody, ScansListScansError, TData>(
    queryKeyFn({ path: '/api/v2/scans', operationId: 'scansListScans', variables }),
    () => fetchScansListScans({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type ScansCreateScanQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansCreateScanError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansCreateScanVariables = {
  body: Schemas.CreateScanRequestBody
  queryParams: ScansCreateScanQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Security Test Scan
 */
export const fetchScansCreateScan = (variables: ScansCreateScanVariables) =>
  stoFetch<Schemas.IDResult, ScansCreateScanError, Schemas.CreateScanRequestBody, {}, ScansCreateScanQueryParams, {}>({
    url: '/api/v2/scans',
    method: 'post',
    ...variables
  })

/**
 * Create a new Security Test Scan
 */
export const useScansCreateScan = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.IDResult, ScansCreateScanError, ScansCreateScanVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.IDResult, ScansCreateScanError, ScansCreateScanVariables>(
    (variables: ScansCreateScanVariables) => fetchScansCreateScan({ ...fetcherOptions, ...variables }),
    options
  )
}

export type ScansDeleteScanPathParams = {
  /*
   * The ID of the Security Test Scan to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ScansDeleteScanQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansDeleteScanError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansDeleteScanVariables = {
  pathParams: ScansDeleteScanPathParams
  queryParams: ScansDeleteScanQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Security Test Scan
 */
export const fetchScansDeleteScan = (variables: ScansDeleteScanVariables) =>
  stoFetch<undefined, ScansDeleteScanError, undefined, {}, ScansDeleteScanQueryParams, ScansDeleteScanPathParams>({
    url: '/api/v2/scans/{id}',
    method: 'delete',
    ...variables
  })

/**
 * Delete an existing Security Test Scan
 */
export const useScansDeleteScan = (
  options?: Omit<reactQuery.UseMutationOptions<undefined, ScansDeleteScanError, ScansDeleteScanVariables>, 'mutationFn'>
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<undefined, ScansDeleteScanError, ScansDeleteScanVariables>(
    (variables: ScansDeleteScanVariables) => fetchScansDeleteScan({ ...fetcherOptions, ...variables }),
    options
  )
}

export type ScansFindScanByIdPathParams = {
  /*
   * The ID of the Security Test Scan to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ScansFindScanByIdQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansFindScanByIdError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansFindScanByIdVariables = {
  pathParams: ScansFindScanByIdPathParams
  queryParams: ScansFindScanByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Security Test Scan by ID
 */
export const fetchScansFindScanById = (variables: ScansFindScanByIdVariables) =>
  stoFetch<
    Schemas.Scan,
    ScansFindScanByIdError,
    undefined,
    {},
    ScansFindScanByIdQueryParams,
    ScansFindScanByIdPathParams
  >({ url: '/api/v2/scans/{id}', method: 'get', ...variables })

/**
 * Find Security Test Scan by ID
 */
export const useScansFindScanById = <TData>(
  variables: ScansFindScanByIdVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.Scan, ScansFindScanByIdError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Scan, ScansFindScanByIdError, TData>(
    queryKeyFn({ path: '/api/v2/scans/{id}', operationId: 'scansFindScanById', variables }),
    () => fetchScansFindScanById({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type ScansUpdateScanPathParams = {
  /*
   * The ID of the Security Test Scan to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type ScansUpdateScanQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansUpdateScanError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansUpdateScanVariables = {
  body: Schemas.UpdateScanRequestBody
  pathParams: ScansUpdateScanPathParams
  queryParams: ScansUpdateScanQueryParams
} & StoContext['fetcherOptions']

/**
 * Update an existing Security Test Scan
 */
export const fetchScansUpdateScan = (variables: ScansUpdateScanVariables) =>
  stoFetch<
    Schemas.Scan,
    ScansUpdateScanError,
    Schemas.UpdateScanRequestBody,
    {},
    ScansUpdateScanQueryParams,
    ScansUpdateScanPathParams
  >({ url: '/api/v2/scans/{id}', method: 'put', ...variables })

/**
 * Update an existing Security Test Scan
 */
export const useScansUpdateScan = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Scan, ScansUpdateScanError, ScansUpdateScanVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.Scan, ScansUpdateScanError, ScansUpdateScanVariables>(
    (variables: ScansUpdateScanVariables) => fetchScansUpdateScan({ ...fetcherOptions, ...variables }),
    options
  )
}

export type ScansScanIssuePathParams = {
  /*
   * The ID of the Security Test Scan
   *
   * @example Pariatur qui natus sed ipsa quis.
   */
  id: string
  /*
   * The ID of the Security Test Issue
   *
   * @example Non sit fugit sit velit quis voluptas.
   */
  issueId: string
}

export type ScansScanIssueQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type ScansScanIssueError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansScanIssueVariables = {
  pathParams: ScansScanIssuePathParams
  queryParams: ScansScanIssueQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns a scan specific issue
 */
export const fetchScansScanIssue = (variables: ScansScanIssueVariables) =>
  stoFetch<Schemas.Issue, ScansScanIssueError, undefined, {}, ScansScanIssueQueryParams, ScansScanIssuePathParams>({
    url: '/api/v2/scans/{id}/issue/{issueId}',
    method: 'get',
    ...variables
  })

/**
 * Returns a scan specific issue
 */
export const useScansScanIssue = <TData>(
  variables: ScansScanIssueVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.Issue, ScansScanIssueError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Issue, ScansScanIssueError, TData>(
    queryKeyFn({ path: '/api/v2/scans/{id}/issue/{issueId}', operationId: 'scansScanIssue', variables }),
    () => fetchScansScanIssue({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type ScansScanIssueCountsPathParams = {
  /*
   * The ID of the Security Test Scan for which to count issues
   *
   * @example Soluta maxime itaque et omnis odit voluptates.
   */
  id: string
}

export type ScansScanIssueCountsQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type ScansScanIssueCountsError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type ScansScanIssueCountsVariables = {
  pathParams: ScansScanIssueCountsPathParams
  queryParams: ScansScanIssueCountsQueryParams
} & StoContext['fetcherOptions']

/**
 * Returns counts of active Security Issues for a Security Test Scan
 */
export const fetchScansScanIssueCounts = (variables: ScansScanIssueCountsVariables) =>
  stoFetch<
    Schemas.IssueCounts,
    ScansScanIssueCountsError,
    undefined,
    {},
    ScansScanIssueCountsQueryParams,
    ScansScanIssueCountsPathParams
  >({ url: '/api/v2/scans/{id}/issues/counts', method: 'get', ...variables })

/**
 * Returns counts of active Security Issues for a Security Test Scan
 */
export const useScansScanIssueCounts = <TData>(
  variables: ScansScanIssueCountsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.IssueCounts, ScansScanIssueCountsError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.IssueCounts, ScansScanIssueCountsError, TData>(
    queryKeyFn({ path: '/api/v2/scans/{id}/issues/counts', operationId: 'scansScanIssueCounts', variables }),
    () => fetchScansScanIssueCounts({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type SystemHealthError = ErrorWrapper<{
  status: 500
  payload: Schemas.NotFound
}>

export type SystemHealthVariables = StoContext['fetcherOptions']

/**
 * Check service health
 */
export const fetchSystemHealth = (variables: SystemHealthVariables) =>
  stoFetch<undefined, SystemHealthError, undefined, {}, {}, {}>({
    url: '/api/v2/system/health',
    method: 'get',
    ...variables
  })

/**
 * Check service health
 */
export const useSystemHealth = <TData>(
  variables: SystemHealthVariables,
  options?: Omit<reactQuery.UseQueryOptions<undefined, SystemHealthError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<undefined, SystemHealthError, TData>(
    queryKeyFn({ path: '/api/v2/system/health', operationId: 'systemHealth', variables }),
    () => fetchSystemHealth({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type SystemVersionError = ErrorWrapper<undefined>

export type SystemVersionVariables = StoContext['fetcherOptions']

/**
 * Get service version
 */
export const fetchSystemVersion = (variables: SystemVersionVariables) =>
  stoFetch<Schemas.ServiceVersion, SystemVersionError, undefined, {}, {}, {}>({
    url: '/api/v2/system/version',
    method: 'get',
    ...variables
  })

/**
 * Get service version
 */
export const useSystemVersion = <TData>(
  variables: SystemVersionVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.ServiceVersion, SystemVersionError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.ServiceVersion, SystemVersionError, TData>(
    queryKeyFn({ path: '/api/v2/system/version', operationId: 'systemVersion', variables }),
    () => fetchSystemVersion({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type TargetsListTargetsQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @minimum 0
   */
  page?: number
  /*
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
  /*
   * Resource name
   *
   * @example NodeGoat
   */
  name?: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsListTargetsError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsListTargetsVariables = {
  queryParams: TargetsListTargetsQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Scan Targets
 */
export const fetchTargetsListTargets = (variables: TargetsListTargetsVariables) =>
  stoFetch<
    Schemas.TargetsListTargetsResponseBody,
    TargetsListTargetsError,
    undefined,
    {},
    TargetsListTargetsQueryParams,
    {}
  >({ url: '/api/v2/targets', method: 'get', ...variables })

/**
 * List a collection of Scan Targets
 */
export const useTargetsListTargets = <TData>(
  variables: TargetsListTargetsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.TargetsListTargetsResponseBody, TargetsListTargetsError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.TargetsListTargetsResponseBody, TargetsListTargetsError, TData>(
    queryKeyFn({ path: '/api/v2/targets', operationId: 'targetsListTargets', variables }),
    () => fetchTargetsListTargets({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type TargetsCreateTargetQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsCreateTargetError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsCreateTargetVariables = {
  body: Schemas.CreateTargetRequestBody
  queryParams: TargetsCreateTargetQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Scan Target
 */
export const fetchTargetsCreateTarget = (variables: TargetsCreateTargetVariables) =>
  stoFetch<
    Schemas.IDResult,
    TargetsCreateTargetError,
    Schemas.CreateTargetRequestBody,
    {},
    TargetsCreateTargetQueryParams,
    {}
  >({ url: '/api/v2/targets', method: 'post', ...variables })

/**
 * Create a new Scan Target
 */
export const useTargetsCreateTarget = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.IDResult, TargetsCreateTargetError, TargetsCreateTargetVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.IDResult, TargetsCreateTargetError, TargetsCreateTargetVariables>(
    (variables: TargetsCreateTargetVariables) => fetchTargetsCreateTarget({ ...fetcherOptions, ...variables }),
    options
  )
}

export type TargetsDeleteTargetPathParams = {
  /*
   * The ID of the Scan Target to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetsDeleteTargetQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsDeleteTargetError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsDeleteTargetVariables = {
  pathParams: TargetsDeleteTargetPathParams
  queryParams: TargetsDeleteTargetQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Scan Target
 */
export const fetchTargetsDeleteTarget = (variables: TargetsDeleteTargetVariables) =>
  stoFetch<
    undefined,
    TargetsDeleteTargetError,
    undefined,
    {},
    TargetsDeleteTargetQueryParams,
    TargetsDeleteTargetPathParams
  >({ url: '/api/v2/targets/{id}', method: 'delete', ...variables })

/**
 * Delete an existing Scan Target
 */
export const useTargetsDeleteTarget = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, TargetsDeleteTargetError, TargetsDeleteTargetVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<undefined, TargetsDeleteTargetError, TargetsDeleteTargetVariables>(
    (variables: TargetsDeleteTargetVariables) => fetchTargetsDeleteTarget({ ...fetcherOptions, ...variables }),
    options
  )
}

export type TargetsFindTargetByIdPathParams = {
  /*
   * The ID of the Scan Target to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetsFindTargetByIdQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsFindTargetByIdError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsFindTargetByIdVariables = {
  pathParams: TargetsFindTargetByIdPathParams
  queryParams: TargetsFindTargetByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Scan Target by ID
 */
export const fetchTargetsFindTargetById = (variables: TargetsFindTargetByIdVariables) =>
  stoFetch<
    Schemas.Target,
    TargetsFindTargetByIdError,
    undefined,
    {},
    TargetsFindTargetByIdQueryParams,
    TargetsFindTargetByIdPathParams
  >({ url: '/api/v2/targets/{id}', method: 'get', ...variables })

/**
 * Find Scan Target by ID
 */
export const useTargetsFindTargetById = <TData>(
  variables: TargetsFindTargetByIdVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.Target, TargetsFindTargetByIdError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.Target, TargetsFindTargetByIdError, TData>(
    queryKeyFn({ path: '/api/v2/targets/{id}', operationId: 'targetsFindTargetById', variables }),
    () => fetchTargetsFindTargetById({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type TargetsPatchTargetPathParams = {
  /*
   * The ID of the Scan Target to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetsPatchTargetQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsPatchTargetError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsPatchTargetVariables = {
  body?: Schemas.PatchTargetRequestBody
  pathParams: TargetsPatchTargetPathParams
  queryParams: TargetsPatchTargetQueryParams
} & StoContext['fetcherOptions']

/**
 * Update only certain fields on an existing Scan Target
 */
export const fetchTargetsPatchTarget = (variables: TargetsPatchTargetVariables) =>
  stoFetch<
    Schemas.Target,
    TargetsPatchTargetError,
    Schemas.PatchTargetRequestBody,
    {},
    TargetsPatchTargetQueryParams,
    TargetsPatchTargetPathParams
  >({ url: '/api/v2/targets/{id}', method: 'patch', ...variables })

/**
 * Update only certain fields on an existing Scan Target
 */
export const useTargetsPatchTarget = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Target, TargetsPatchTargetError, TargetsPatchTargetVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.Target, TargetsPatchTargetError, TargetsPatchTargetVariables>(
    (variables: TargetsPatchTargetVariables) => fetchTargetsPatchTarget({ ...fetcherOptions, ...variables }),
    options
  )
}

export type TargetsUpdateTargetPathParams = {
  /*
   * The ID of the Scan Target to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetsUpdateTargetQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Harness Organization ID
   *
   * @example example_org
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  orgId: string
  /*
   * Harness Project ID
   *
   * @example example_project
   * @pattern ^[A-Za-z_][A-Za-z0-9_]*$
   * @maxLength 128
   */
  projectId: string
}

export type TargetsUpdateTargetError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetsUpdateTargetVariables = {
  body: Schemas.UpdateTargetRequestBody
  pathParams: TargetsUpdateTargetPathParams
  queryParams: TargetsUpdateTargetQueryParams
} & StoContext['fetcherOptions']

/**
 * Update an existing Scan Target
 */
export const fetchTargetsUpdateTarget = (variables: TargetsUpdateTargetVariables) =>
  stoFetch<
    Schemas.Target,
    TargetsUpdateTargetError,
    Schemas.UpdateTargetRequestBody,
    {},
    TargetsUpdateTargetQueryParams,
    TargetsUpdateTargetPathParams
  >({ url: '/api/v2/targets/{id}', method: 'put', ...variables })

/**
 * Update an existing Scan Target
 */
export const useTargetsUpdateTarget = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Target, TargetsUpdateTargetError, TargetsUpdateTargetVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<Schemas.Target, TargetsUpdateTargetError, TargetsUpdateTargetVariables>(
    (variables: TargetsUpdateTargetVariables) => fetchTargetsUpdateTarget({ ...fetcherOptions, ...variables }),
    options
  )
}

export type TargetVariantsListTargetVariantsPathParams = {
  /*
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
}

export type TargetVariantsListTargetVariantsQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
  /*
   * Page number to fetch (starting from 0)
   *
   * @default 0
   * @example 4
   * @minimum 0
   */
  page?: number
  /*
   * Number of results per page
   *
   * @default 30
   * @example 50
   * @minimum 1
   * @maximum 100
   */
  pageSize?: number
}

export type TargetVariantsListTargetVariantsError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsListTargetVariantsVariables = {
  pathParams: TargetVariantsListTargetVariantsPathParams
  queryParams: TargetVariantsListTargetVariantsQueryParams
} & StoContext['fetcherOptions']

/**
 * List a collection of Scan Target Variants
 */
export const fetchTargetVariantsListTargetVariants = (variables: TargetVariantsListTargetVariantsVariables) =>
  stoFetch<
    Schemas.TargetVariantsListTargetVariantsResponseBody,
    TargetVariantsListTargetVariantsError,
    undefined,
    {},
    TargetVariantsListTargetVariantsQueryParams,
    TargetVariantsListTargetVariantsPathParams
  >({ url: '/api/v2/targets/{targetId}/variants', method: 'get', ...variables })

/**
 * List a collection of Scan Target Variants
 */
export const useTargetVariantsListTargetVariants = <TData>(
  variables: TargetVariantsListTargetVariantsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TargetVariantsListTargetVariantsResponseBody,
      TargetVariantsListTargetVariantsError,
      TData
    >,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<
    Schemas.TargetVariantsListTargetVariantsResponseBody,
    TargetVariantsListTargetVariantsError,
    TData
  >(
    queryKeyFn({
      path: '/api/v2/targets/{targetId}/variants',
      operationId: 'targetVariantsListTargetVariants',
      variables
    }),
    () => fetchTargetVariantsListTargetVariants({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type TargetVariantsCreateTargetVariantPathParams = {
  /*
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
}

export type TargetVariantsCreateTargetVariantQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TargetVariantsCreateTargetVariantError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsCreateTargetVariantVariables = {
  body: Schemas.CreateTargetVariantRequestBody
  pathParams: TargetVariantsCreateTargetVariantPathParams
  queryParams: TargetVariantsCreateTargetVariantQueryParams
} & StoContext['fetcherOptions']

/**
 * Create a new Scan Target Variant
 */
export const fetchTargetVariantsCreateTargetVariant = (variables: TargetVariantsCreateTargetVariantVariables) =>
  stoFetch<
    Schemas.IDResult,
    TargetVariantsCreateTargetVariantError,
    Schemas.CreateTargetVariantRequestBody,
    {},
    TargetVariantsCreateTargetVariantQueryParams,
    TargetVariantsCreateTargetVariantPathParams
  >({ url: '/api/v2/targets/{targetId}/variants', method: 'post', ...variables })

/**
 * Create a new Scan Target Variant
 */
export const useTargetVariantsCreateTargetVariant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.IDResult,
      TargetVariantsCreateTargetVariantError,
      TargetVariantsCreateTargetVariantVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.IDResult,
    TargetVariantsCreateTargetVariantError,
    TargetVariantsCreateTargetVariantVariables
  >(
    (variables: TargetVariantsCreateTargetVariantVariables) =>
      fetchTargetVariantsCreateTargetVariant({ ...fetcherOptions, ...variables }),
    options
  )
}

export type TargetVariantsDeleteTargetVariantPathParams = {
  /*
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
  /*
   * The ID of the Scan Target Variant to delete
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetVariantsDeleteTargetVariantQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TargetVariantsDeleteTargetVariantError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsDeleteTargetVariantVariables = {
  pathParams: TargetVariantsDeleteTargetVariantPathParams
  queryParams: TargetVariantsDeleteTargetVariantQueryParams
} & StoContext['fetcherOptions']

/**
 * Delete an existing Scan Target Variant
 */
export const fetchTargetVariantsDeleteTargetVariant = (variables: TargetVariantsDeleteTargetVariantVariables) =>
  stoFetch<
    undefined,
    TargetVariantsDeleteTargetVariantError,
    undefined,
    {},
    TargetVariantsDeleteTargetVariantQueryParams,
    TargetVariantsDeleteTargetVariantPathParams
  >({ url: '/api/v2/targets/{targetId}/variants/{id}', method: 'delete', ...variables })

/**
 * Delete an existing Scan Target Variant
 */
export const useTargetVariantsDeleteTargetVariant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      TargetVariantsDeleteTargetVariantError,
      TargetVariantsDeleteTargetVariantVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    undefined,
    TargetVariantsDeleteTargetVariantError,
    TargetVariantsDeleteTargetVariantVariables
  >(
    (variables: TargetVariantsDeleteTargetVariantVariables) =>
      fetchTargetVariantsDeleteTargetVariant({ ...fetcherOptions, ...variables }),
    options
  )
}

export type TargetVariantsFindTargetVariantByIdPathParams = {
  /*
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
  /*
   * The ID of the Scan Target Variant to retrieve
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetVariantsFindTargetVariantByIdQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TargetVariantsFindTargetVariantByIdError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsFindTargetVariantByIdVariables = {
  pathParams: TargetVariantsFindTargetVariantByIdPathParams
  queryParams: TargetVariantsFindTargetVariantByIdQueryParams
} & StoContext['fetcherOptions']

/**
 * Find Scan Target Variant by ID
 */
export const fetchTargetVariantsFindTargetVariantById = (variables: TargetVariantsFindTargetVariantByIdVariables) =>
  stoFetch<
    Schemas.TargetVariant,
    TargetVariantsFindTargetVariantByIdError,
    undefined,
    {},
    TargetVariantsFindTargetVariantByIdQueryParams,
    TargetVariantsFindTargetVariantByIdPathParams
  >({ url: '/api/v2/targets/{targetId}/variants/{id}', method: 'get', ...variables })

/**
 * Find Scan Target Variant by ID
 */
export const useTargetVariantsFindTargetVariantById = <TData>(
  variables: TargetVariantsFindTargetVariantByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.TargetVariant, TargetVariantsFindTargetVariantByIdError, TData>,
    'queryKey' | 'queryFn'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.TargetVariant, TargetVariantsFindTargetVariantByIdError, TData>(
    queryKeyFn({
      path: '/api/v2/targets/{targetId}/variants/{id}',
      operationId: 'targetVariantsFindTargetVariantById',
      variables
    }),
    () => fetchTargetVariantsFindTargetVariantById({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type TargetVariantsUpdateTargetVariantPathParams = {
  /*
   * Associated Target ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  targetId: string
  /*
   * The ID of the Scan Target Variant to update
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  id: string
}

export type TargetVariantsUpdateTargetVariantQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TargetVariantsUpdateTargetVariantError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 404
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TargetVariantsUpdateTargetVariantVariables = {
  body: Schemas.UpdateTargetVariantRequestBody
  pathParams: TargetVariantsUpdateTargetVariantPathParams
  queryParams: TargetVariantsUpdateTargetVariantQueryParams
} & StoContext['fetcherOptions']

/**
 * Update an existing Scan Target Variant
 */
export const fetchTargetVariantsUpdateTargetVariant = (variables: TargetVariantsUpdateTargetVariantVariables) =>
  stoFetch<
    Schemas.TargetVariant,
    TargetVariantsUpdateTargetVariantError,
    Schemas.UpdateTargetVariantRequestBody,
    {},
    TargetVariantsUpdateTargetVariantQueryParams,
    TargetVariantsUpdateTargetVariantPathParams
  >({ url: '/api/v2/targets/{targetId}/variants/{id}', method: 'put', ...variables })

/**
 * Update an existing Scan Target Variant
 */
export const useTargetVariantsUpdateTargetVariant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TargetVariant,
      TargetVariantsUpdateTargetVariantError,
      TargetVariantsUpdateTargetVariantVariables
    >,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useStoContext()
  return reactQuery.useMutation<
    Schemas.TargetVariant,
    TargetVariantsUpdateTargetVariantError,
    TargetVariantsUpdateTargetVariantVariables
  >(
    (variables: TargetVariantsUpdateTargetVariantVariables) =>
      fetchTargetVariantsUpdateTargetVariant({ ...fetcherOptions, ...variables }),
    options
  )
}

export type TokenIssueTokenQueryParams = {
  /*
   * Harness Account ID
   *
   * @example abcdef1234567890ghijkl
   * @pattern ^[a-zA-Z0-9_-]{22}$
   */
  accountId: string
}

export type TokenIssueTokenHeaders = {
  /*
   * Harness internal shared secret
   *
   * @example 3q7uiERGH78heq3weg
   */
  ['X-Harness-Token']: string
}

export type TokenIssueTokenError = ErrorWrapper<
  | {
      status: 400
      payload: Schemas.NotFound
    }
  | {
      status: 401
      payload: Schemas.NotFound
    }
  | {
      status: 403
      payload: Schemas.NotFound
    }
  | {
      status: 500
      payload: Schemas.NotFound
    }
>

export type TokenIssueTokenVariables = {
  headers: TokenIssueTokenHeaders
  queryParams: TokenIssueTokenQueryParams
} & StoContext['fetcherOptions']

/**
 * Issue a cross-service token
 */
export const fetchTokenIssueToken = (variables: TokenIssueTokenVariables) =>
  stoFetch<
    Schemas.TokenResponse,
    TokenIssueTokenError,
    undefined,
    TokenIssueTokenHeaders,
    TokenIssueTokenQueryParams,
    {}
  >({ url: '/api/v2/token', method: 'get', ...variables })

/**
 * Issue a cross-service token
 */
export const useTokenIssueToken = <TData>(
  variables: TokenIssueTokenVariables,
  options?: Omit<reactQuery.UseQueryOptions<Schemas.TokenResponse, TokenIssueTokenError, TData>, 'queryKey' | 'queryFn'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useStoContext(options)
  return reactQuery.useQuery<Schemas.TokenResponse, TokenIssueTokenError, TData>(
    queryKeyFn({ path: '/api/v2/token', operationId: 'tokenIssueToken', variables }),
    () => fetchTokenIssueToken({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions
    }
  )
}

export type QueryOperation =
  | {
      path: '/api/usage'
      operationId: 'usageReportUsage'
      variables: UsageReportUsageVariables
    }
  | {
      path: '/api/v1/token'
      operationId: 'tokenV1IssueTokenV1'
      variables: TokenV1IssueTokenV1Variables
    }
  | {
      path: '/api/v2/exemptions'
      operationId: 'exemptionsListExemptions'
      variables: ExemptionsListExemptionsVariables
    }
  | {
      path: '/api/v2/exemptions/{id}'
      operationId: 'exemptionsFindExemptionById'
      variables: ExemptionsFindExemptionByIdVariables
    }
  | {
      path: '/api/v2/frontend/issue-counts'
      operationId: 'frontendExecutionIssueCounts'
      variables: FrontendExecutionIssueCountsVariables
    }
  | {
      path: '/api/v2/frontend/overview'
      operationId: 'frontendOverview'
      variables: FrontendOverviewVariables
    }
  | {
      path: '/api/v2/frontend/pipeline-security'
      operationId: 'frontendPipelineSecurity'
      variables: FrontendPipelineSecurityVariables
    }
  | {
      path: '/api/v2/frontend/security-review'
      operationId: 'frontendSecurityReview'
      variables: FrontendSecurityReviewVariables
    }
  | {
      path: '/api/v2/frontend/test-targets'
      operationId: 'frontendTestTargets'
      variables: FrontendTestTargetsVariables
    }
  | {
      path: '/api/v2/issues'
      operationId: 'issuesListIssues'
      variables: IssuesListIssuesVariables
    }
  | {
      path: '/api/v2/issues/{id}'
      operationId: 'issuesFindIssueById'
      variables: IssuesFindIssueByIdVariables
    }
  | {
      path: '/api/v2/products'
      operationId: 'productsListProducts'
      variables: ProductsListProductsVariables
    }
  | {
      path: '/api/v2/products/{id}'
      operationId: 'productsFindProductById'
      variables: ProductsFindProductByIdVariables
    }
  | {
      path: '/api/v2/scans'
      operationId: 'scansListScans'
      variables: ScansListScansVariables
    }
  | {
      path: '/api/v2/scans/{id}'
      operationId: 'scansFindScanById'
      variables: ScansFindScanByIdVariables
    }
  | {
      path: '/api/v2/scans/{id}/issue/{issueId}'
      operationId: 'scansScanIssue'
      variables: ScansScanIssueVariables
    }
  | {
      path: '/api/v2/scans/{id}/issues/counts'
      operationId: 'scansScanIssueCounts'
      variables: ScansScanIssueCountsVariables
    }
  | {
      path: '/api/v2/system/health'
      operationId: 'systemHealth'
      variables: SystemHealthVariables
    }
  | {
      path: '/api/v2/system/version'
      operationId: 'systemVersion'
      variables: SystemVersionVariables
    }
  | {
      path: '/api/v2/targets'
      operationId: 'targetsListTargets'
      variables: TargetsListTargetsVariables
    }
  | {
      path: '/api/v2/targets/{id}'
      operationId: 'targetsFindTargetById'
      variables: TargetsFindTargetByIdVariables
    }
  | {
      path: '/api/v2/targets/{targetId}/variants'
      operationId: 'targetVariantsListTargetVariants'
      variables: TargetVariantsListTargetVariantsVariables
    }
  | {
      path: '/api/v2/targets/{targetId}/variants/{id}'
      operationId: 'targetVariantsFindTargetVariantById'
      variables: TargetVariantsFindTargetVariantByIdVariables
    }
  | {
      path: '/api/v2/token'
      operationId: 'tokenIssueToken'
      variables: TokenIssueTokenVariables
    }
